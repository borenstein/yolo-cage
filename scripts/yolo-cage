#!/usr/bin/env python3
"""yolo-cage - Host CLI for managing sandboxed Claude Code agents

This script runs on the user's host machine and manages the VM lifecycle,
delegating pod operations to yolo-cage-inner inside the VM.
"""

import argparse
import json
import os
import re
import shutil
import subprocess
import sys
import urllib.request
import urllib.error
from pathlib import Path

YOLO_CAGE_VERSION="dev"  # Replaced by release workflow
YOLO_CAGE_HOME = Path(os.environ.get("YOLO_CAGE_HOME", Path.home() / ".yolo-cage"))
YOLO_CAGE_REPO = "https://github.com/borenstein/yolo-cage.git"

# Colors
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
NC = "\033[0m"


def log_step(msg: str) -> None:
    print(f"{YELLOW}-> {msg}{NC}")


def log_success(msg: str) -> None:
    print(f"{GREEN}OK {msg}{NC}")


def log_error(msg: str) -> None:
    print(f"{RED}ERROR: {msg}{NC}", file=sys.stderr)


def die(msg: str) -> None:
    log_error(msg)
    sys.exit(1)


def parse_github_repo(repo_url: str) -> tuple[str, str] | None:
    """Extract owner and repo name from a GitHub URL.

    Supports:
      - https://github.com/owner/repo
      - https://github.com/owner/repo.git
      - git@github.com:owner/repo.git

    Returns (owner, repo) or None if not a valid GitHub URL.
    """
    # HTTPS format
    match = re.match(r"https://github\.com/([^/]+)/([^/]+?)(?:\.git)?/?$", repo_url)
    if match:
        return match.group(1), match.group(2)

    # SSH format
    match = re.match(r"git@github\.com:([^/]+)/([^/]+?)(?:\.git)?$", repo_url)
    if match:
        return match.group(1), match.group(2)

    return None


def validate_github_repo(repo_url: str, pat: str) -> tuple[bool, str]:
    """Check if a GitHub repository is accessible with the given PAT.

    Returns (success, message) tuple.
    """
    parsed = parse_github_repo(repo_url)
    if not parsed:
        return False, f"Could not parse GitHub URL: {repo_url}"

    owner, repo = parsed
    api_url = f"https://api.github.com/repos/{owner}/{repo}"

    req = urllib.request.Request(api_url)
    req.add_header("Authorization", f"token {pat}")
    req.add_header("Accept", "application/vnd.github.v3+json")
    req.add_header("User-Agent", "yolo-cage")

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode())
            # Check if we have push access
            permissions = data.get("permissions", {})
            if not permissions.get("push"):
                return False, f"PAT does not have push access to {owner}/{repo}"
            return True, f"Repository {owner}/{repo} is accessible"
    except urllib.error.HTTPError as e:
        if e.code == 404:
            return False, f"Repository not found: {owner}/{repo}\nCheck that the repository exists and your PAT has access to it."
        elif e.code == 401:
            return False, "Invalid GitHub PAT or PAT has expired."
        elif e.code == 403:
            return False, f"Access denied to {owner}/{repo}. Check your PAT permissions."
        else:
            return False, f"GitHub API error: {e.code} {e.reason}"
    except urllib.error.URLError as e:
        return False, f"Could not connect to GitHub: {e.reason}"
    except Exception as e:
        return False, f"Unexpected error validating repository: {e}"


def detect_repo_dir() -> Path | None:
    """Check if running from within the repo (development mode)."""
    script_dir = Path(__file__).resolve().parent
    repo_dir = script_dir.parent

    if (repo_dir / "Vagrantfile").exists():
        return repo_dir
    elif (YOLO_CAGE_HOME / "repo").is_dir():
        return YOLO_CAGE_HOME / "repo"
    return None


def vagrant_provider_args() -> list[str]:
    """Return provider args for vagrant commands. macOS requires qemu."""
    if sys.platform == "darwin":
        return ["--provider=qemu"]
    return []


def check_prerequisites() -> None:
    """Verify required tools are installed."""
    missing = []
    is_macos = sys.platform == "darwin"

    if not shutil.which("vagrant"):
        missing.append("vagrant")

    if not shutil.which("git"):
        missing.append("git")

    if is_macos:
        # macOS requires QEMU + vagrant-qemu plugin
        result = subprocess.run(
            ["brew", "list", "--formula"],
            capture_output=True,
            text=True,
        )
        installed_formulas = result.stdout if result.returncode == 0 else ""
        if "qemu" not in installed_formulas:
            missing.append("qemu")

        # Check for vagrant-qemu plugin
        if shutil.which("vagrant"):
            result = subprocess.run(
                ["vagrant", "plugin", "list"],
                capture_output=True,
                text=True,
            )
            if "vagrant-qemu" not in result.stdout:
                missing.append("vagrant-qemu plugin")
    else:
        # On Linux, check for libvirtd or VirtualBox
        has_vbox = shutil.which("VBoxManage") is not None
        has_libvirt = shutil.which("libvirtd") is not None
        if not has_libvirt and not has_vbox:
            missing.append("libvirt (or VirtualBox)")

        # Check for vagrant-libvirt plugin if using libvirt
        if shutil.which("vagrant") and has_libvirt:
            result = subprocess.run(
                ["vagrant", "plugin", "list"],
                capture_output=True,
                text=True,
            )
            if "vagrant-libvirt" not in result.stdout:
                missing.append("vagrant-libvirt plugin")

    if missing:
        print("Missing prerequisites:")
        for dep in missing:
            print(f"  - {dep}")
        print()
        print("Install with:")
        print()
        if is_macos:
            print("  macOS:")
            print("    brew install vagrant qemu")
            print("    vagrant plugin install vagrant-qemu")
        else:
            print("  Ubuntu/Debian:")
            print("    sudo apt install vagrant vagrant-libvirt qemu-kvm libvirt-daemon-system")
            print()
            print("  Fedora:")
            print("    sudo dnf install vagrant vagrant-libvirt qemu-kvm libvirt")
        sys.exit(1)


def ensure_repo() -> Path:
    """Return repo directory, or exit if not found."""
    repo_dir = detect_repo_dir()
    if not repo_dir:
        die("yolo-cage repository not found. Run 'yolo-cage build' first.")
    return repo_dir


def ensure_vm_running() -> None:
    """Exit if VM is not running."""
    repo_dir = ensure_repo()

    result = subprocess.run(
        ["vagrant", "status", "--machine-readable"],
        cwd=repo_dir,
        capture_output=True,
        text=True,
    )

    status = "unknown"
    for line in result.stdout.splitlines():
        if ",state," in line:
            status = line.split(",")[3]
            break

    if status != "running":
        die("VM is not running. Start with 'yolo-cage up'.")


def vagrant_ssh(repo_dir: Path, command: str, interactive: bool = False) -> int:
    """Run a command inside the VM via vagrant ssh."""
    if interactive:
        return subprocess.call(
            ["vagrant", "ssh", "--", "-t", command],
            cwd=repo_dir,
        )
    else:
        return subprocess.call(
            ["vagrant", "ssh", "-c", command],
            cwd=repo_dir,
        )


def load_config() -> dict[str, str]:
    """Load configuration from config.env file."""
    config_path = YOLO_CAGE_HOME / "config.env"
    if not config_path.exists():
        return {}

    config = {}
    with open(config_path) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#") and "=" in line:
                key, value = line.split("=", 1)
                config[key.strip()] = value.strip()
    return config


def prompt_config() -> None:
    """Interactively prompt for configuration."""
    YOLO_CAGE_HOME.mkdir(parents=True, exist_ok=True)

    print("yolo-cage configuration")
    print()

    github_pat = input("GitHub PAT: ").strip()
    if not github_pat:
        die("GitHub PAT is required")

    repo_url = input("Repository URL: ").strip()
    if not repo_url:
        die("Repository URL is required")

    # Validate repository access before continuing
    log_step("Validating repository access...")
    valid, message = validate_github_repo(repo_url, github_pat)
    if not valid:
        die(message)
    log_success(message)
    print()

    git_name = input("Git name [yolo-cage]: ").strip() or "yolo-cage"
    git_email = input("Git email [yolo-cage@localhost]: ").strip() or "yolo-cage@localhost"
    claude_oauth = input("Claude OAuth token (optional, press Enter to skip): ").strip()
    proxy_bypass = input("Proxy bypass domains (optional, comma-separated): ").strip()

    config_path = YOLO_CAGE_HOME / "config.env"
    with open(config_path, "w") as f:
        f.write(f"# yolo-cage configuration\n")
        f.write(f"# Generated by yolo-cage build --interactive\n\n")
        f.write(f"# Required\n")
        f.write(f"GITHUB_PAT={github_pat}\n")
        f.write(f"REPO_URL={repo_url}\n\n")
        f.write(f"# Git identity\n")
        f.write(f"GIT_NAME={git_name}\n")
        f.write(f"GIT_EMAIL={git_email}\n")

        if claude_oauth:
            f.write(f"\nCLAUDE_OAUTH={claude_oauth}\n")

        if proxy_bypass:
            f.write(f"\nPROXY_BYPASS={proxy_bypass}\n")

    log_success(f"Config written to {config_path}")


def sync_config_to_vm() -> None:
    """Copy config to VM and apply it."""
    repo_dir = ensure_repo()
    config_path = YOLO_CAGE_HOME / "config.env"

    if not config_path.exists():
        die("No config found. Run 'yolo-cage build' with --config-file or --interactive.")

    log_step("Syncing configuration to VM...")
    vagrant_ssh(repo_dir, "mkdir -p ~/.yolo-cage")

    # Copy config file content to VM
    config_content = config_path.read_text()
    subprocess.run(
        ["vagrant", "ssh", "-c", "cat > ~/.yolo-cage/config.env"],
        cwd=repo_dir,
        input=config_content,
        text=True,
        check=True,
    )

    log_step("Applying configuration...")
    vagrant_ssh(repo_dir, "yolo-cage-configure")


def cmd_build(args: argparse.Namespace) -> None:
    """Set up yolo-cage (clone repo, build VM)."""
    check_prerequisites()

    if sys.platform == "darwin":
        print()
        print(f"{YELLOW}Note: Apple Silicon support is experimental.{NC}")
        print("The vagrant-qemu plugin has known limitations.")
        print()

    YOLO_CAGE_HOME.mkdir(parents=True, exist_ok=True)

    existing_config = YOLO_CAGE_HOME / "config.env"

    # Handle config
    if args.config_file:
        config_file = Path(args.config_file)
        if not config_file.exists():
            die(f"Config file not found: {config_file}")
        shutil.copy(config_file, YOLO_CAGE_HOME / "config.env")
        log_success(f"Config copied to {YOLO_CAGE_HOME / 'config.env'}")
    elif args.interactive:
        prompt_config()
    elif existing_config.exists():
        log_success(f"Using existing config: {existing_config}")
    else:
        die(
            f"No configuration found.\n\n"
            f"Either:\n"
            f"  - Run with --interactive to create one\n"
            f"  - Run with --config-file to use an existing file\n"
            f"  - Create {existing_config} manually"
        )

    # Clone repo if needed
    repo_dir = detect_repo_dir()
    if not repo_dir:
        log_step("Cloning yolo-cage repository...")
        subprocess.run(
            ["git", "clone", YOLO_CAGE_REPO, str(YOLO_CAGE_HOME / "repo")],
            check=True,
        )
        repo_dir = YOLO_CAGE_HOME / "repo"
        log_success("Repository cloned")

    # Destroy existing VM if present
    vagrant_dir = repo_dir / ".vagrant"
    if vagrant_dir.exists():
        log_step("Destroying existing VM...")
        subprocess.run(["vagrant", "destroy", "-f"], cwd=repo_dir)

    # Build VM
    log_step("Building VM (this may take a while)...")
    subprocess.run(["vagrant", "up"] + vagrant_provider_args(), cwd=repo_dir, check=True)

    # Sync config and apply
    sync_config_to_vm()

    if not args.up:
        subprocess.run(["vagrant", "halt"], cwd=repo_dir, check=True)
        print()
        log_success("VM built successfully!")
        print("Run 'yolo-cage up' to start the VM.")
    else:
        print()
        log_success("VM built and running!")
        print()
        print("Create a sandbox:  yolo-cage create <branch>")
        print("List sandboxes:    yolo-cage list")
        print("Attach to sandbox: yolo-cage attach <branch>")


def cmd_up(args: argparse.Namespace) -> None:
    """Start the VM."""
    repo_dir = ensure_repo()

    if args.ram:
        print("Note: --ram option is not yet implemented. Using default RAM.")

    log_step("Starting VM...")
    subprocess.run(["vagrant", "up"] + vagrant_provider_args(), cwd=repo_dir, check=True)

    log_success("VM is running")
    print()
    print("Create a sandbox:  yolo-cage create <branch>")
    print("List sandboxes:    yolo-cage list")


def cmd_down(args: argparse.Namespace) -> None:
    """Stop the VM."""
    repo_dir = ensure_repo()

    log_step("Stopping VM...")
    subprocess.run(["vagrant", "halt"], cwd=repo_dir, check=True)

    log_success("VM stopped")


def cmd_destroy(args: argparse.Namespace) -> None:
    """Remove the VM entirely."""
    repo_dir = ensure_repo()

    print("This will destroy the VM and all data inside it.")
    print(f"Your config in {YOLO_CAGE_HOME / 'config.env'} will be preserved.")
    print()
    confirm = input("Continue? [y/N] ").strip().lower()

    if confirm not in ("y", "yes"):
        print("Aborted.")
        return

    log_step("Destroying VM...")
    subprocess.run(["vagrant", "destroy", "-f"], cwd=repo_dir, check=True)

    log_success("VM destroyed")


def cmd_configure(args: argparse.Namespace) -> None:
    """Update configuration and sync to VM."""
    if args.interactive:
        prompt_config()
    else:
        config_path = YOLO_CAGE_HOME / "config.env"
        if not config_path.exists():
            die(f"No config found at {config_path}\nRun 'yolo-cage configure --interactive' to create one.")

        # Validate the config before syncing
        config = load_config()
        pat = config.get("GITHUB_PAT")
        repo_url = config.get("REPO_URL")

        if not pat or not repo_url:
            die("Missing GITHUB_PAT or REPO_URL in config.")

        log_step("Validating repository access...")
        valid, message = validate_github_repo(repo_url, pat)
        if not valid:
            die(message)
        log_success(message)

    # Sync to VM if it's running
    repo_dir = detect_repo_dir()
    if repo_dir:
        result = subprocess.run(
            ["vagrant", "status", "--machine-readable"],
            cwd=repo_dir,
            capture_output=True,
            text=True,
        )
        vm_running = any(",state,running" in line for line in result.stdout.splitlines())

        if vm_running:
            sync_config_to_vm()
        else:
            log_success(f"Config saved to {YOLO_CAGE_HOME / 'config.env'}")
            print("VM is not running. Config will be applied on next 'yolo-cage up'.")
    else:
        log_success(f"Config saved to {YOLO_CAGE_HOME / 'config.env'}")


def cmd_create(args: argparse.Namespace) -> None:
    """Create a sandbox pod for a branch."""
    ensure_vm_running()
    repo_dir = ensure_repo()

    # Validate repository access before creating pod
    config = load_config()
    pat = config.get("GITHUB_PAT")
    repo_url = config.get("REPO_URL")

    if not pat or not repo_url:
        die("Missing GITHUB_PAT or REPO_URL in config. Run 'yolo-cage configure'.")

    log_step("Validating repository access...")
    valid, message = validate_github_repo(repo_url, pat)
    if not valid:
        die(message)
    log_success(message)

    vagrant_ssh(repo_dir, f"yolo-cage-inner create '{args.branch}'")


def cmd_attach(args: argparse.Namespace) -> None:
    """Attach to a sandbox pod (tmux session)."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner attach '{args.branch}'", interactive=True)


def cmd_shell(args: argparse.Namespace) -> None:
    """Open a shell in a sandbox pod."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner shell '{args.branch}'", interactive=True)


def cmd_list(args: argparse.Namespace) -> None:
    """List all sandbox pods."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, "yolo-cage-inner list")


def cmd_delete(args: argparse.Namespace) -> None:
    """Delete a sandbox pod."""
    ensure_vm_running()
    repo_dir = ensure_repo()

    cmd = f"yolo-cage-inner delete '{args.branch}'"
    if args.clean:
        cmd += " --clean"

    vagrant_ssh(repo_dir, cmd)


def cmd_logs(args: argparse.Namespace) -> None:
    """Tail pod logs."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner logs '{args.branch}'")


def cmd_port_forward(args: argparse.Namespace) -> None:
    """Forward a port from a sandbox pod to localhost."""
    ensure_vm_running()
    repo_dir = ensure_repo()

    # Parse port spec: "8080" or "local:remote"
    if ":" in args.port:
        local_port, pod_port = args.port.split(":", 1)
    else:
        local_port = pod_port = args.port

    # Validate ports are numeric
    try:
        int(local_port)
        int(pod_port)
    except ValueError:
        die(f"Invalid port specification: {args.port}")

    bind_addr = args.bind
    branch = args.branch
    pod_name = f"yolo-cage-{branch}"

    print(f"Forwarding {bind_addr}:{local_port} â†’ {pod_name}:{pod_port}")
    print("Press Ctrl+C to stop")
    print()

    # Use SSH tunnel (-L) combined with kubectl port-forward
    # The -L flag creates: host:local_port -> VM:local_port
    # kubectl port-forward creates: VM:local_port -> pod:pod_port
    kubectl_cmd = f"kubectl port-forward -n yolo-cage pod/{pod_name} {local_port}:{pod_port}"
    ssh_cmd = [
        "vagrant", "ssh", "--",
        "-L", f"{bind_addr}:{local_port}:localhost:{local_port}",
        kubectl_cmd,
    ]

    try:
        subprocess.call(ssh_cmd, cwd=repo_dir)
    except KeyboardInterrupt:
        print("\nPort forwarding stopped.")


def cmd_upgrade(args: argparse.Namespace) -> None:
    """Upgrade yolo-cage to the latest version."""
    import tempfile
    import urllib.request

    repo_dir = detect_repo_dir()

    # Step 1: Update the CLI binary
    log_step("Downloading latest yolo-cage CLI...")
    cli_url = "https://github.com/borenstein/yolo-cage/releases/latest/download/yolo-cage"

    try:
        with tempfile.NamedTemporaryFile(delete=False) as tmp:
            urllib.request.urlretrieve(cli_url, tmp.name)
            tmp_path = tmp.name

        # Make executable and move to /usr/local/bin
        os.chmod(tmp_path, 0o755)
        target = "/usr/local/bin/yolo-cage"

        # Try to copy (may need sudo)
        try:
            shutil.copy(tmp_path, target)
            log_success("CLI updated")
        except PermissionError:
            print(f"Need sudo to update {target}")
            result = subprocess.run(["sudo", "cp", tmp_path, target])
            if result.returncode == 0:
                log_success("CLI updated")
            else:
                die("Failed to update CLI")
        finally:
            os.unlink(tmp_path)

    except Exception as e:
        die(f"Failed to download CLI: {e}")

    # Step 2: Update the repo
    if repo_dir and repo_dir == YOLO_CAGE_HOME / "repo":
        log_step("Updating repository...")
        result = subprocess.run(
            ["git", "pull", "--ff-only"],
            cwd=repo_dir,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            log_success("Repository updated")
        else:
            log_error(f"Failed to update repository: {result.stderr}")
            print("You may need to manually resolve conflicts in ~/.yolo-cage/repo")
    elif repo_dir:
        print(f"Skipping repo update (running from dev repo: {repo_dir})")

    # Step 3: Optionally rebuild VM
    if args.rebuild:
        if not repo_dir:
            die("No repository found. Run 'yolo-cage build' first.")
        log_step("Rebuilding VM with updated code...")
        subprocess.run(["vagrant", "destroy", "-f"], cwd=repo_dir)
        subprocess.run(["vagrant", "up"] + vagrant_provider_args(), cwd=repo_dir, check=True)
        sync_config_to_vm()
        log_success("VM rebuilt")
    else:
        print()
        print("CLI and repo updated. Run 'yolo-cage build' to update the VM.")


def cmd_status(args: argparse.Namespace) -> None:
    """Show VM and pod status."""
    repo_dir = detect_repo_dir()

    if not repo_dir:
        print("Status: Not built")
        print()
        print("Run 'yolo-cage build --interactive --up' to get started.")
        return

    result = subprocess.run(
        ["vagrant", "status", "--machine-readable"],
        cwd=repo_dir,
        capture_output=True,
        text=True,
    )

    vm_status = "unknown"
    for line in result.stdout.splitlines():
        if ",state," in line:
            vm_status = line.split(",")[3]
            break

    print(f"Repository: {repo_dir}")
    print(f"Config: {YOLO_CAGE_HOME / 'config.env'}")
    print(f"VM status: {vm_status}")

    if vm_status == "running":
        print()
        print("Pods:")
        vagrant_ssh(repo_dir, "yolo-cage-inner list")


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="yolo-cage",
        description="Sandboxed Claude Code agents",
    )
    parser.add_argument(
        "--version", "-v", "--v",
        action="version",
        version=f"yolo-cage {YOLO_CAGE_VERSION}",
    )

    subparsers = parser.add_subparsers(dest="command", metavar="<command>")

    # version (subcommand alias for --version)
    def cmd_version(args: argparse.Namespace) -> None:
        print(f"yolo-cage {YOLO_CAGE_VERSION}")

    p_version = subparsers.add_parser(
        "version",
        help="Show version",
    )
    p_version.set_defaults(func=cmd_version)

    # build
    p_build = subparsers.add_parser(
        "build",
        help="Set up yolo-cage (clone repo, build VM)",
        description="Set up yolo-cage by cloning the repository and building the VM.",
    )
    p_build.add_argument(
        "--config-file",
        metavar="FILE",
        help="Path to config.env file",
    )
    p_build.add_argument(
        "--interactive",
        action="store_true",
        help="Prompt for configuration interactively",
    )
    p_build.add_argument(
        "--up",
        action="store_true",
        help="Keep VM running after build",
    )
    p_build.set_defaults(func=cmd_build)

    # upgrade
    p_upgrade = subparsers.add_parser(
        "upgrade",
        help="Upgrade to latest version",
        description="Download the latest CLI, update the repo, and optionally rebuild the VM.",
    )
    p_upgrade.add_argument(
        "--rebuild",
        action="store_true",
        help="Also rebuild the VM after upgrading",
    )
    p_upgrade.set_defaults(func=cmd_upgrade)

    # up
    p_up = subparsers.add_parser(
        "up",
        help="Start the VM",
        aliases=["start"],
    )
    p_up.add_argument(
        "--ram",
        metavar="SIZE",
        help="RAM size (not yet implemented)",
    )
    p_up.set_defaults(func=cmd_up)

    # down
    p_down = subparsers.add_parser(
        "down",
        help="Stop the VM",
        aliases=["stop", "halt"],
    )
    p_down.set_defaults(func=cmd_down)

    # destroy
    p_destroy = subparsers.add_parser(
        "destroy",
        help="Remove the VM entirely",
        description="Destroy the VM and all data inside it. Your config.env will be preserved.",
    )
    p_destroy.set_defaults(func=cmd_destroy)

    # configure
    p_configure = subparsers.add_parser(
        "configure",
        help="Update configuration and sync to VM",
        description="Validate and sync configuration to the VM. Use --interactive to re-enter credentials.",
    )
    p_configure.add_argument(
        "--interactive", "-i",
        action="store_true",
        help="Prompt for configuration interactively",
    )
    p_configure.set_defaults(func=cmd_configure)

    # status
    p_status = subparsers.add_parser(
        "status",
        help="Show VM and pod status",
    )
    p_status.set_defaults(func=cmd_status)

    # create
    p_create = subparsers.add_parser(
        "create",
        help="Create a sandbox pod for a branch",
    )
    p_create.add_argument("branch", help="Git branch name")
    p_create.set_defaults(func=cmd_create)

    # attach
    p_attach = subparsers.add_parser(
        "attach",
        help="Start interactive Claude Code session",
    )
    p_attach.add_argument("branch", help="Git branch name")
    p_attach.set_defaults(func=cmd_attach)

    # shell
    p_shell = subparsers.add_parser(
        "shell",
        help="Open a shell in a sandbox pod",
        aliases=["sh"],
    )
    p_shell.add_argument("branch", help="Git branch name")
    p_shell.set_defaults(func=cmd_shell)

    # list
    p_list = subparsers.add_parser(
        "list",
        help="List all sandbox pods",
        aliases=["ls"],
    )
    p_list.set_defaults(func=cmd_list)

    # delete
    p_delete = subparsers.add_parser(
        "delete",
        help="Delete a sandbox pod",
        aliases=["rm"],
    )
    p_delete.add_argument("branch", help="Git branch name")
    p_delete.add_argument(
        "--clean",
        action="store_true",
        help="Also delete workspace files",
    )
    p_delete.set_defaults(func=cmd_delete)

    # logs
    p_logs = subparsers.add_parser(
        "logs",
        help="Tail pod logs",
    )
    p_logs.add_argument("branch", help="Git branch name")
    p_logs.set_defaults(func=cmd_logs)

    # port-forward
    p_port_forward = subparsers.add_parser(
        "port-forward",
        help="Forward a port from a sandbox pod",
        description="Forward a port from a sandbox pod to your local machine.",
    )
    p_port_forward.add_argument("branch", help="Git branch name")
    p_port_forward.add_argument(
        "port",
        help="Port specification: PORT or LOCAL:POD (e.g., 8080 or 9000:3000)",
    )
    p_port_forward.add_argument(
        "--bind",
        default="127.0.0.1",
        metavar="ADDR",
        help="Bind address (default: 127.0.0.1, use 0.0.0.0 for LAN access)",
    )
    p_port_forward.set_defaults(func=cmd_port_forward)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    args.func(args)


if __name__ == "__main__":
    main()
