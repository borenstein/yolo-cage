#!/usr/bin/env python3
"""yolo-cage - Host CLI for managing sandboxed Claude Code agents

This script runs on the user's host machine and manages the VM lifecycle,
delegating pod operations to yolo-cage-inner inside the VM.
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path

VERSION = "dev"
YOLO_CAGE_HOME = Path(os.environ.get("YOLO_CAGE_HOME", Path.home() / ".yolo-cage"))
YOLO_CAGE_REPO = "https://github.com/borenstein/yolo-cage.git"

# Colors
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
NC = "\033[0m"


def log_step(msg: str) -> None:
    print(f"{YELLOW}-> {msg}{NC}")


def log_success(msg: str) -> None:
    print(f"{GREEN}OK {msg}{NC}")


def log_error(msg: str) -> None:
    print(f"{RED}ERROR: {msg}{NC}", file=sys.stderr)


def die(msg: str) -> None:
    log_error(msg)
    sys.exit(1)


def detect_repo_dir() -> Path | None:
    """Check if running from within the repo (development mode)."""
    script_dir = Path(__file__).resolve().parent
    repo_dir = script_dir.parent

    if (repo_dir / "Vagrantfile").exists():
        return repo_dir
    elif (YOLO_CAGE_HOME / "repo").is_dir():
        return YOLO_CAGE_HOME / "repo"
    return None


def check_prerequisites() -> None:
    """Verify required tools are installed."""
    missing = []

    if not shutil.which("vagrant"):
        missing.append("vagrant")

    if not shutil.which("git"):
        missing.append("git")

    # Check for either libvirt or VirtualBox
    if shutil.which("vagrant"):
        result = subprocess.run(
            ["vagrant", "plugin", "list"],
            capture_output=True,
            text=True,
        )
        has_libvirt = "vagrant-libvirt" in result.stdout
        has_vbox = shutil.which("VBoxManage") is not None

        if not has_libvirt and not has_vbox:
            missing.append("vagrant-libvirt plugin OR VirtualBox")

    if missing:
        print("Missing prerequisites:")
        for dep in missing:
            print(f"  - {dep}")
        print()
        print("Install with:")
        print("  Ubuntu/Debian: sudo apt install vagrant vagrant-libvirt")
        print("  Fedora: sudo dnf install vagrant vagrant-libvirt")
        print("  macOS: brew install vagrant && vagrant plugin install vagrant-libvirt")
        sys.exit(1)


def ensure_repo() -> Path:
    """Return repo directory, or exit if not found."""
    repo_dir = detect_repo_dir()
    if not repo_dir:
        die("yolo-cage repository not found. Run 'yolo-cage build' first.")
    return repo_dir


def ensure_vm_running() -> None:
    """Exit if VM is not running."""
    repo_dir = ensure_repo()

    result = subprocess.run(
        ["vagrant", "status", "--machine-readable"],
        cwd=repo_dir,
        capture_output=True,
        text=True,
    )

    status = "unknown"
    for line in result.stdout.splitlines():
        if ",state," in line:
            status = line.split(",")[3]
            break

    if status != "running":
        die("VM is not running. Start with 'yolo-cage up'.")


def vagrant_ssh(repo_dir: Path, command: str, interactive: bool = False) -> int:
    """Run a command inside the VM via vagrant ssh."""
    if interactive:
        return subprocess.call(
            ["vagrant", "ssh", "--", "-t", command],
            cwd=repo_dir,
        )
    else:
        return subprocess.call(
            ["vagrant", "ssh", "-c", command],
            cwd=repo_dir,
        )


def prompt_config() -> None:
    """Interactively prompt for configuration."""
    YOLO_CAGE_HOME.mkdir(parents=True, exist_ok=True)

    print("yolo-cage configuration")
    print()

    github_pat = input("GitHub PAT: ").strip()
    if not github_pat:
        die("GitHub PAT is required")

    repo_url = input("Repository URL: ").strip()
    if not repo_url:
        die("Repository URL is required")

    git_name = input("Git name [yolo-cage]: ").strip() or "yolo-cage"
    git_email = input("Git email [yolo-cage@localhost]: ").strip() or "yolo-cage@localhost"
    claude_oauth = input("Claude OAuth token (optional, press Enter to skip): ").strip()
    proxy_bypass = input("Proxy bypass domains (optional, comma-separated): ").strip()

    config_path = YOLO_CAGE_HOME / "config.env"
    with open(config_path, "w") as f:
        f.write(f"# yolo-cage configuration\n")
        f.write(f"# Generated by yolo-cage build --interactive\n\n")
        f.write(f"# Required\n")
        f.write(f"GITHUB_PAT={github_pat}\n")
        f.write(f"REPO_URL={repo_url}\n\n")
        f.write(f"# Git identity\n")
        f.write(f"GIT_NAME={git_name}\n")
        f.write(f"GIT_EMAIL={git_email}\n")

        if claude_oauth:
            f.write(f"\nCLAUDE_OAUTH={claude_oauth}\n")

        if proxy_bypass:
            f.write(f"\nPROXY_BYPASS={proxy_bypass}\n")

    log_success(f"Config written to {config_path}")


def sync_config_to_vm() -> None:
    """Copy config to VM and apply it."""
    repo_dir = ensure_repo()
    config_path = YOLO_CAGE_HOME / "config.env"

    if not config_path.exists():
        die("No config found. Run 'yolo-cage build' with --config-file or --interactive.")

    log_step("Syncing configuration to VM...")
    vagrant_ssh(repo_dir, "mkdir -p ~/.yolo-cage")

    # Copy config file content to VM
    config_content = config_path.read_text()
    subprocess.run(
        ["vagrant", "ssh", "-c", "cat > ~/.yolo-cage/config.env"],
        cwd=repo_dir,
        input=config_content,
        text=True,
        check=True,
    )

    log_step("Applying configuration...")
    vagrant_ssh(repo_dir, "yolo-cage-configure")


def cmd_build(args: argparse.Namespace) -> None:
    """Set up yolo-cage (clone repo, build VM)."""
    if not args.config_file and not args.interactive:
        die("Must specify --config-file or --interactive")

    check_prerequisites()
    YOLO_CAGE_HOME.mkdir(parents=True, exist_ok=True)

    # Handle config
    if args.config_file:
        config_file = Path(args.config_file)
        if not config_file.exists():
            die(f"Config file not found: {config_file}")
        shutil.copy(config_file, YOLO_CAGE_HOME / "config.env")
        log_success(f"Config copied to {YOLO_CAGE_HOME / 'config.env'}")
    else:
        prompt_config()

    # Clone repo if needed
    repo_dir = detect_repo_dir()
    if not repo_dir:
        log_step("Cloning yolo-cage repository...")
        subprocess.run(
            ["git", "clone", YOLO_CAGE_REPO, str(YOLO_CAGE_HOME / "repo")],
            check=True,
        )
        repo_dir = YOLO_CAGE_HOME / "repo"
        log_success("Repository cloned")

    # Build VM
    log_step("Building VM (this may take a while)...")
    subprocess.run(["vagrant", "up"], cwd=repo_dir, check=True)

    # Sync config and apply
    sync_config_to_vm()

    if not args.up:
        subprocess.run(["vagrant", "halt"], cwd=repo_dir, check=True)
        print()
        log_success("VM built successfully!")
        print("Run 'yolo-cage up' to start the VM.")
    else:
        print()
        log_success("VM built and running!")
        print()
        print("Create a sandbox:  yolo-cage create <branch>")
        print("List sandboxes:    yolo-cage list")
        print("Attach to sandbox: yolo-cage attach <branch>")


def cmd_rebuild(args: argparse.Namespace) -> None:
    """Destroy and rebuild the VM (preserves config)."""
    repo_dir = ensure_repo()

    print("This will destroy the current VM and rebuild it.")
    print(f"Your config in {YOLO_CAGE_HOME / 'config.env'} will be preserved.")
    print()
    confirm = input("Continue? [y/N] ").strip().lower()

    if confirm not in ("y", "yes"):
        print("Aborted.")
        return

    log_step("Destroying existing VM...")
    subprocess.run(["vagrant", "destroy", "-f"], cwd=repo_dir)

    log_step("Rebuilding VM...")
    subprocess.run(["vagrant", "up"], cwd=repo_dir, check=True)

    sync_config_to_vm()
    log_success("VM rebuilt successfully!")


def cmd_up(args: argparse.Namespace) -> None:
    """Start the VM."""
    repo_dir = ensure_repo()

    if args.ram:
        print("Note: --ram option is not yet implemented. Using default RAM.")

    log_step("Starting VM...")
    subprocess.run(["vagrant", "up"], cwd=repo_dir, check=True)

    log_success("VM is running")
    print()
    print("Create a sandbox:  yolo-cage create <branch>")
    print("List sandboxes:    yolo-cage list")


def cmd_down(args: argparse.Namespace) -> None:
    """Stop the VM."""
    repo_dir = ensure_repo()

    log_step("Stopping VM...")
    subprocess.run(["vagrant", "halt"], cwd=repo_dir, check=True)

    log_success("VM stopped")


def cmd_destroy(args: argparse.Namespace) -> None:
    """Remove the VM entirely."""
    repo_dir = ensure_repo()

    print("This will destroy the VM and all data inside it.")
    print(f"Your config in {YOLO_CAGE_HOME / 'config.env'} will be preserved.")
    print()
    confirm = input("Continue? [y/N] ").strip().lower()

    if confirm not in ("y", "yes"):
        print("Aborted.")
        return

    log_step("Destroying VM...")
    subprocess.run(["vagrant", "destroy", "-f"], cwd=repo_dir, check=True)

    log_success("VM destroyed")


def cmd_create(args: argparse.Namespace) -> None:
    """Create a sandbox pod for a branch."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner create '{args.branch}'")


def cmd_attach(args: argparse.Namespace) -> None:
    """Attach to a sandbox pod (tmux session)."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner attach '{args.branch}'", interactive=True)


def cmd_shell(args: argparse.Namespace) -> None:
    """Open a shell in a sandbox pod."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner shell '{args.branch}'", interactive=True)


def cmd_list(args: argparse.Namespace) -> None:
    """List all sandbox pods."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, "yolo-cage-inner list")


def cmd_delete(args: argparse.Namespace) -> None:
    """Delete a sandbox pod."""
    ensure_vm_running()
    repo_dir = ensure_repo()

    cmd = f"yolo-cage-inner delete '{args.branch}'"
    if args.clean:
        cmd += " --clean"

    vagrant_ssh(repo_dir, cmd)


def cmd_logs(args: argparse.Namespace) -> None:
    """Tail pod logs."""
    ensure_vm_running()
    repo_dir = ensure_repo()
    vagrant_ssh(repo_dir, f"yolo-cage-inner logs '{args.branch}'")


def cmd_port_forward(args: argparse.Namespace) -> None:
    """Forward a port from a sandbox pod to localhost."""
    ensure_vm_running()
    repo_dir = ensure_repo()

    # Parse port spec: "8080" or "local:remote"
    if ":" in args.port:
        local_port, pod_port = args.port.split(":", 1)
    else:
        local_port = pod_port = args.port

    # Validate ports are numeric
    try:
        int(local_port)
        int(pod_port)
    except ValueError:
        die(f"Invalid port specification: {args.port}")

    bind_addr = args.bind
    branch = args.branch
    pod_name = f"yolo-cage-{branch}"

    print(f"Forwarding {bind_addr}:{local_port} â†’ {pod_name}:{pod_port}")
    print("Press Ctrl+C to stop")
    print()

    # Use SSH tunnel (-L) combined with kubectl port-forward
    # The -L flag creates: host:local_port -> VM:local_port
    # kubectl port-forward creates: VM:local_port -> pod:pod_port
    kubectl_cmd = f"kubectl port-forward -n yolo-cage pod/{pod_name} {local_port}:{pod_port}"
    ssh_cmd = [
        "vagrant", "ssh", "--",
        "-L", f"{bind_addr}:{local_port}:localhost:{local_port}",
        kubectl_cmd,
    ]

    try:
        subprocess.call(ssh_cmd, cwd=repo_dir)
    except KeyboardInterrupt:
        print("\nPort forwarding stopped.")


def cmd_status(args: argparse.Namespace) -> None:
    """Show VM and pod status."""
    repo_dir = detect_repo_dir()

    if not repo_dir:
        print("Status: Not built")
        print()
        print("Run 'yolo-cage build --interactive --up' to get started.")
        return

    result = subprocess.run(
        ["vagrant", "status", "--machine-readable"],
        cwd=repo_dir,
        capture_output=True,
        text=True,
    )

    vm_status = "unknown"
    for line in result.stdout.splitlines():
        if ",state," in line:
            vm_status = line.split(",")[3]
            break

    print(f"Repository: {repo_dir}")
    print(f"Config: {YOLO_CAGE_HOME / 'config.env'}")
    print(f"VM status: {vm_status}")

    if vm_status == "running":
        print()
        print("Pods:")
        vagrant_ssh(repo_dir, "yolo-cage-inner list")


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="yolo-cage",
        description="Sandboxed Claude Code agents",
    )
    parser.add_argument(
        "--version", "-v", "--v",
        action="version",
        version=f"yolo-cage {VERSION}",
    )

    subparsers = parser.add_subparsers(dest="command", metavar="<command>")

    # version (subcommand alias for --version)
    def cmd_version(args: argparse.Namespace) -> None:
        print(f"yolo-cage {VERSION}")

    p_version = subparsers.add_parser(
        "version",
        help="Show version",
    )
    p_version.set_defaults(func=cmd_version)

    # build
    p_build = subparsers.add_parser(
        "build",
        help="Set up yolo-cage (clone repo, build VM)",
        description="Set up yolo-cage by cloning the repository and building the VM.",
    )
    p_build.add_argument(
        "--config-file",
        metavar="FILE",
        help="Path to config.env file",
    )
    p_build.add_argument(
        "--interactive",
        action="store_true",
        help="Prompt for configuration interactively",
    )
    p_build.add_argument(
        "--up",
        action="store_true",
        help="Keep VM running after build",
    )
    p_build.set_defaults(func=cmd_build)

    # rebuild
    p_rebuild = subparsers.add_parser(
        "rebuild",
        help="Destroy and rebuild VM (preserves config)",
        description="Destroy the current VM and rebuild it from scratch. Your config.env will be preserved.",
    )
    p_rebuild.set_defaults(func=cmd_rebuild)

    # up
    p_up = subparsers.add_parser(
        "up",
        help="Start the VM",
        aliases=["start"],
    )
    p_up.add_argument(
        "--ram",
        metavar="SIZE",
        help="RAM size (not yet implemented)",
    )
    p_up.set_defaults(func=cmd_up)

    # down
    p_down = subparsers.add_parser(
        "down",
        help="Stop the VM",
        aliases=["stop", "halt"],
    )
    p_down.set_defaults(func=cmd_down)

    # destroy
    p_destroy = subparsers.add_parser(
        "destroy",
        help="Remove the VM entirely",
        description="Destroy the VM and all data inside it. Your config.env will be preserved.",
    )
    p_destroy.set_defaults(func=cmd_destroy)

    # status
    p_status = subparsers.add_parser(
        "status",
        help="Show VM and pod status",
    )
    p_status.set_defaults(func=cmd_status)

    # create
    p_create = subparsers.add_parser(
        "create",
        help="Create a sandbox pod for a branch",
    )
    p_create.add_argument("branch", help="Git branch name")
    p_create.set_defaults(func=cmd_create)

    # attach
    p_attach = subparsers.add_parser(
        "attach",
        help="Start interactive Claude Code session",
    )
    p_attach.add_argument("branch", help="Git branch name")
    p_attach.set_defaults(func=cmd_attach)

    # shell
    p_shell = subparsers.add_parser(
        "shell",
        help="Open a shell in a sandbox pod",
        aliases=["sh"],
    )
    p_shell.add_argument("branch", help="Git branch name")
    p_shell.set_defaults(func=cmd_shell)

    # list
    p_list = subparsers.add_parser(
        "list",
        help="List all sandbox pods",
        aliases=["ls"],
    )
    p_list.set_defaults(func=cmd_list)

    # delete
    p_delete = subparsers.add_parser(
        "delete",
        help="Delete a sandbox pod",
        aliases=["rm"],
    )
    p_delete.add_argument("branch", help="Git branch name")
    p_delete.add_argument(
        "--clean",
        action="store_true",
        help="Also delete workspace files",
    )
    p_delete.set_defaults(func=cmd_delete)

    # logs
    p_logs = subparsers.add_parser(
        "logs",
        help="Tail pod logs",
    )
    p_logs.add_argument("branch", help="Git branch name")
    p_logs.set_defaults(func=cmd_logs)

    # port-forward
    p_port_forward = subparsers.add_parser(
        "port-forward",
        help="Forward a port from a sandbox pod",
        description="Forward a port from a sandbox pod to your local machine.",
    )
    p_port_forward.add_argument("branch", help="Git branch name")
    p_port_forward.add_argument(
        "port",
        help="Port specification: PORT or LOCAL:POD (e.g., 8080 or 9000:3000)",
    )
    p_port_forward.add_argument(
        "--bind",
        default="127.0.0.1",
        metavar="ADDR",
        help="Bind address (default: 127.0.0.1, use 0.0.0.0 for LAN access)",
    )
    p_port_forward.set_defaults(func=cmd_port_forward)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    args.func(args)


if __name__ == "__main__":
    main()
